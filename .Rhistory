ggplot(results, aes(x = results$logFC, y = results$logP, color = expression)) +
geom_point(alpha = 0.5) +
scale_color_manual(values = c('red', 'grey', 'blue')) +
theme_minimal() +
labs(x = "Log Fold Change", y = "Log 2 FDR values", title = "Volcano Plot") +
geom_vline(xintercept = c(-0.25, 0.25), linetype = "dotted") +
geom_hline(yintercept = -log2(0.05), linetype = "dotted")
# Load the libraries
library(ggplot2)
library(dplyr)
results <- qlf_output_hits$table
results$logP <- -log2(results$FDR)
results <- results %>%
mutate(expression = case_when(
logFC > 0.25 & results$FDR < 0.05 ~ "Upregulated",
logFC < -0.25 & results$FDR < 0.05 ~ "Downregulated",
TRUE ~ "No change"
))
ggplot(results, aes(x = results$logFC, y = results$logP, color = expression)) +
geom_point(alpha = 0.5) +
scale_color_manual(values = c('red', 'grey', 'blue')) +
theme_minimal() +
labs(x = "Log Fold Change", y = "Log 2 FDR values", title = "Volcano Plot") +
geom_vline(xintercept = c(-0.25, 0.25), linetype = "dotted") +
geom_hline(yintercept = -log2(0.05), linetype = "dotted")
top_hits <- rownames(qlf_output_hits$table)[qlf_output_hits$table$PValue<0.05]
heatmap_matrix_tophits <- t(scale(t(heatmap_matrix[which(rownames(heatmap_matrix)
top_hits <- rownames(qlf_output_hits$table)[qlf_output_hits$table$PValue<0.05]
top_hits <- rownames(qlf_output_hits$table)[qlf_output_hits$table$PValue<0.05]
heatmap_matrix_tophits <- t(scale(t(heatmap_matrix[which(rownames(heatmap_matrix) %in% top_hits),])))
results
top_hits <- rownames(qlf_output_hits$table)[qlf_output_hits$table$PValue<0.05]
heatmap_matrix_tophits <- t(scale(t(heatmap_matrix[rownames(heatmap_matrix) %in% top_hits,])))
hich(rownames(heatmap_matrix)
%in% top_hits),])
which(rownames(heatmap_matrix) %in% top_hits),])
which(rownames(heatmap_matrix) %in% top_hits)])
which(rownames(heatmap_matrix) %in% top_hits),])
# Check if 'heatmap_matrix' exists
if (!exists("heatmap_matrix")) {
stop("The object 'heatmap_matrix' does not exist in the current environment.")
} else {
# If it exists, proceed with the transpose and scaling
heatmap_matrix_tophits <- t(scale(t(heatmap_matrix[rownames(heatmap_matrix) %in% top_hits,])))
}
normalized_count_data
heatmap_matrix <- normalized_counts[,3:ncol(normalized_counts)]
normalized_counts
sig_genes <- rownames(qlf_output_hits)[which(qlf_output_hits$FDR < 0.5)]
sig_genes
which(qlf_output_hits$FDR < 0.5)
qlf_output_hits$FDR
sig_genes <- rownames(qlf_output_hits)[which(qlf_output_hits$table$FDR < 0.5)]
# Get indices of significant genes in counts data
sig_baseline_idx <- which(rownames(normalized_counts) %in% sig_genes)
top_hits <- rownames(qlf_output_hits$table)[qlf_output_hits$table$PValue<0.05]
heatmap_matrix_tophits <- t(scale(t(heatmap_matrix[rownames(heatmap_matrix) %in% top_hits,])))
if(min(heatmap_matrix_tophits) == 0){
heatmap_col = colorRamp2(c( 0, max(heatmap_matrix_tophits)),
c( "white", "red"))
} else {
heatmap_col = colorRamp2(c(min(heatmap_matrix_tophits), 0,
max(heatmap_matrix_tophits)),
c("blue", "white", "red"))
}
sig_genes
sig_baseline_idx <- which(rownames(normalized_counts) %in% rownames(qlf_output_hits)[which(qlf_output_hits$table$FDR < 0.5)])
sig_baseline_idx
heatmap_matrix_tophits <- t(
scale(t(as.matrix(normalized_counts[top_hits,]))))
if(min(heatmap_matrix_tophits) == 0){
heatmap_col = colorRamp2(c( 0, max(heatmap_matrix_tophits)),
c( "white", "red"))
} else {
heatmap_col = colorRamp2(c(min(heatmap_matrix_tophits), 0,
max(heatmap_matrix_tophits)),
c("blue", "white", "red"))
}
top_hits <- which(rownames(normalized_counts) %in% rownames(qlf_output_hits)[which(qlf_output_hits$table$FDR < 0.05)])
heatmap_matrix_tophits <- t(
scale(t(as.matrix(normalized_counts[top_hits,]))))
if(min(heatmap_matrix_tophits) == 0){
heatmap_col = colorRamp2(c( 0, max(heatmap_matrix_tophits)),
c( "white", "red"))
} else {
heatmap_col = colorRamp2(c(min(heatmap_matrix_tophits), 0,
max(heatmap_matrix_tophits)),
c("blue", "white", "red"))
}
# Load the libraries
library(ggplot2)
library(dplyr)
results <- qlf_output_hits$table
# Create the important variables
results$logP <- -log10(results$FDR)
results <- results %>%
mutate(expression = case_when(
logFC > 0.25 & results$FDR < 0.05 ~ "Upregulated",
logFC < -0.25 & results$FDR < 0.05 ~ "Downregulated",
TRUE ~ "No change"
))
# Create the volcano plot
ggplot(results, aes(x = results$logFC, y = results$logP, color = expression)) +
geom_point(alpha = 0.5) +
scale_color_manual(values = c('red', 'grey', 'blue')) +
theme_minimal() +
labs(x = "Log Fold Change", y = "Log 2 FDR values", title = "Volcano Plot") +
geom_vline(xintercept = c(-0.25, 0.25), linetype = "dotted") +
geom_hline(yintercept = -log2(0.05), linetype = "dotted")
top_hits <- which(rownames(normalized_counts) %in% rownames(qlf_output_hits)[which(qlf_output_hits$table$FDR < 0.05)])
heatmap_matrix_tophits <- t(
scale(t(as.matrix(normalized_counts[top_hits,]))))
if(min(heatmap_matrix_tophits) == 0){
heatmap_col = colorRamp2(c( 0, max(heatmap_matrix_tophits)),
c( "white", "red"))
} else {
heatmap_col = colorRamp2(c(min(heatmap_matrix_tophits), 0,
max(heatmap_matrix_tophits)),
c("blue", "white", "red"))
}
install.packages("circlize")
library(circlize)
top_hits <- which(rownames(normalized_counts) %in% rownames(qlf_output_hits)[which(qlf_output_hits$table$FDR < 0.05)])
heatmap_matrix_tophits <- t(
scale(t(as.matrix(normalized_counts[top_hits,]))))
if(min(heatmap_matrix_tophits) == 0){
heatmap_col = colorRamp2(c( 0, max(heatmap_matrix_tophits)),
c( "white", "red"))
} else {
heatmap_col = colorRamp2(c(min(heatmap_matrix_tophits), 0,
max(heatmap_matrix_tophits)),
c("blue", "white", "red"))
}
current_heatmap <- Heatmap(as.matrix(heatmap_matrix_tophits),
cluster_rows = TRUE,
cluster_columns = TRUE,
show_row_dend = TRUE,
show_column_dend = TRUE,
col=heatmap_col,
show_column_names = FALSE,
show_row_names = FALSE,
show_heatmap_legend = TRUE,
)
# Install the ComplexHeatmap package if you haven't already
if (!requireNamespace("ComplexHeatmap", quietly = TRUE)) {
install.packages("BiocManager")
BiocManager::install("ComplexHeatmap")
}
current_heatmap <- Heatmap(as.matrix(heatmap_matrix_tophits),
cluster_rows = TRUE,
cluster_columns = TRUE,
show_row_dend = TRUE,
show_column_dend = TRUE,
col=heatmap_col,
show_column_names = FALSE,
show_row_names = FALSE,
show_heatmap_legend = TRUE,
)
current_heatmap <- Heatmap(as.matrix(heatmap_matrix_tophits),
cluster_rows = TRUE,
cluster_columns = TRUE,
show_row_dend = TRUE,
show_column_dend = TRUE,
col=heatmap_col,
show_column_names = FALSE,
show_row_names = FALSE,
show_heatmap_legend = TRUE,
)
library(ComplexHeatmap)
# Install the ComplexHeatmap package if you haven't already
if (!requireNamespace("ComplexHeatmap", quietly = TRUE)) {
install.packages("BiocManager")
BiocManager::install("ComplexHeatmap")
}
library(ComplexHeatmap)
current_heatmap <- Heatmap(as.matrix(heatmap_matrix_tophits),
cluster_rows = TRUE,
cluster_columns = TRUE,
show_row_dend = TRUE,
show_column_dend = TRUE,
col=heatmap_col,
show_column_names = FALSE,
show_row_names = FALSE,
show_heatmap_legend = TRUE,
)
install.packages("circlize")
library(circlize)
# Install the ComplexHeatmap package if you haven't already
if (!requireNamespace("ComplexHeatmap", quietly = TRUE)) {
install.packages("BiocManager")
BiocManager::install("ComplexHeatmap")
}
# Load the ComplexHeatmap package
library(ComplexHeatmap)
top_hits <- which(rownames(normalized_counts) %in% rownames(qlf_output_hits)[which(qlf_output_hits$table$FDR < 0.05)])
heatmap_matrix_tophits <- t(
scale(t(as.matrix(normalized_counts[top_hits,]))))
if(min(heatmap_matrix_tophits) == 0){
heatmap_col = colorRamp2(c( 0, max(heatmap_matrix_tophits)),
c( "white", "red"))
} else {
heatmap_col = colorRamp2(c(min(heatmap_matrix_tophits), 0,
max(heatmap_matrix_tophits)),
c("blue", "white", "red"))
}
current_heatmap <- Heatmap(as.matrix(heatmap_matrix_tophits),
cluster_rows = TRUE,
cluster_columns = TRUE,
show_row_dend = TRUE,
show_column_dend = TRUE,
col=heatmap_col,
show_column_names = FALSE,
show_row_names = FALSE,
show_heatmap_legend = TRUE,
)
current_heatmap
current_heatmap
install.packages("circlize")
library(circlize)
# Install the ComplexHeatmap package if you haven't already
if (!requireNamespace("ComplexHeatmap", quietly = TRUE)) {
install.packages("BiocManager")
BiocManager::install("ComplexHeatmap")
}
# Load the ComplexHeatmap package
library(ComplexHeatmap)
top_hits <- which(rownames(normalized_counts) %in% rownames(qlf_output_hits)[which(qlf_output_hits$table$FDR < 0.05)])
heatmap_matrix_tophits <- t(
scale(t(as.matrix(normalized_counts[top_hits,]))))
if(min(heatmap_matrix_tophits) == 0){
heatmap_col = colorRamp2(c( 0, max(heatmap_matrix_tophits)),
c( "white", "red"))
} else {
heatmap_col = colorRamp2(c(min(heatmap_matrix_tophits), 0,
max(heatmap_matrix_tophits)),
c("blue", "white", "red"))
}
current_heatmap <- Heatmap(as.matrix(heatmap_matrix_tophits),
cluster_rows = TRUE,
cluster_columns = TRUE,
show_row_dend = TRUE,
show_column_dend = TRUE,
col=heatmap_col,
show_column_names = FALSE,
show_row_names = FALSE,
show_heatmap_legend = TRUE,
)
current_heatmap
Heatmap(scaled_hits_heatmap_matrix,
cluster_rows = TRUE,
cluster_columns = TRUE,
show_row_dend=TRUE,
col = colscale,
show_column_names = TRUE,
show_row_names = FALSE,
show_heatmap_legend=TRUE)
Heatmap(as.matrix(heatmap_matrix_tophits),
cluster_rows = TRUE,
cluster_columns = TRUE,
show_row_dend=TRUE,
col = colscale,
show_column_names = TRUE,
show_row_names = FALSE,
show_heatmap_legend=TRUE)
current_heatmap <- Heatmap(as.matrix(heatmap_matrix_tophits),
cluster_rows = TRUE,
cluster_columns = TRUE,
show_row_dend = TRUE,
show_column_dend = TRUE,
col=heatmap_col,
show_column_names = FALSE,
show_row_names = FALSE,
show_heatmap_legend = TRUE,
)
current_heatmap
Heatmap(as.matrix(heatmap_matrix_tophits),
cluster_rows = TRUE,
cluster_columns = TRUE,
show_row_dend = TRUE,
show_column_dend = TRUE,
col=heatmap_col,
show_column_names = FALSE,
show_row_names = FALSE,
show_heatmap_legend = TRUE)
current_heatmap <- Heatmap(as.matrix(heatmap_matrix_tophits),
show_row_dend = TRUE,show_column_dend = TRUE,
col=heatmap_col,show_column_names = TRUE,
show_row_names = FALSE,show_heatmap_legend = TRUE)
current_heatmap <- Heatmap(as.matrix(heatmap_matrix),
show_row_dend = TRUE,show_column_dend = TRUE,
col=heatmap_col,show_column_names = TRUE,
show_row_names = FALSE,show_heatmap_legend = TRUE)
current_heatmap
normalized_counts
filtered_data_matrix <- luk_data_matrix_cpm[keep, ]
filtered_data_matrix
luk_samples
luk_data
row.names(luk_data_matrix) <- gene_names
luk_data_matrix
# I set the min read value to be 10
min_num_samples <- 10
luk_data_matrix <- as.matrix(luk_data)
# When I used the code from the slide I got an error when the cpm function was applied
# where the error said we need numeric data
# So I figured the error occurs because the first column is a char vector(i.e gene name)
# so ill remove it temporarily and add it later
gene_names <- luk_data_matrix[, 1]
# Now ill convert the rest of the columns to numeric matrix except the first one
luk_data_matrix <- luk_data_matrix[, -1]
row.names(luk_data_matrix) <- gene_names
luk_data_matrix <- apply(luk_data_matrix, 2, as.numeric)
luk_data_matrix_cpm <- as.matrix(luk_data_matrix)
# Complete the cpm step
cpm_data <- edgeR::cpm(luk_data_matrix_cpm)
# Now we will filter the data
keep <- rowSums(cpm_data > 1) >= min_num_samples
filtered_data_matrix <- luk_data_matrix_cpm[keep, ]
# I will apply TMM
d = DGEList(counts=filtered_data_matrix, group=luk_samples_dt$treatment)
# calculate normalization factors
d = calcNormFactors(d)
# apply cpm on the normalized data.
# This is the final data set the question in normalization is asking for
normalized_counts <- cpm(d)
normalized_counts
luk_data_matrix_cpm
luk_data_matrix <- luk_data_matrix[, -1]
row.names(luk_data_matrix) <- gene_names
luk_data_matrix
luk_data_matrix_cpm <- as.matrix(luk_data_matrix)
luk_data_matrix_cpm
luk_data_matrix <- luk_data_matrix[, -1]
luk_data_matrix <- apply(luk_data_matrix, 2, as.numeric)
row.names(luk_data_matrix) <- gene_names
luk_data_matrix_cpm <- as.matrix(luk_data_matrix)
luk_data_matrix_cpm
# Complete the cpm step
cpm_data <- edgeR::cpm(luk_data_matrix_cpm)
# Now we will filter the data
keep <- rowSums(cpm_data > 1) >= min_num_samples
filtered_data_matrix <- luk_data_matrix_cpm[keep, ]
```
# Complete the cpm step
cpm_data <- edgeR::cpm(luk_data_matrix_cpm)
# Now we will filter the data
keep <- rowSums(cpm_data > 1) >= min_num_samples
filtered_data_matrix <- luk_data_matrix_cpm[keep, ]
d = DGEList(counts=filtered_data_matrix, group=luk_samples_dt$treatment)
filtered_data_matrix
d = DGEList(counts=filtered_data_matrix, group=luk_samples_dt$treatment)
length(filtered_data_matrix)
length(luk_samples_dt$treatment)
ncol(filtered_data_matrix)
col(filtered_data_matrix)
filtered_data_matrix
# I set the min read value to be 10
min_num_samples <- 10
luk_data_matrix <- as.matrix(luk_data)
# When I used the code from the slide I got an error when the cpm function was applied
# where the error said we need numeric data
# So I figured the error occurs because the first column is a char vector(i.e gene name)
# so ill remove it temporarily and add it later
gene_names <- luk_data_matrix[, 1]
# Now ill convert the rest of the columns to numeric matrix except the first one
luk_data_matrix <- luk_data_matrix[, -1]
luk_data_matrix <- apply(luk_data_matrix, 2, as.numeric)
row.names(luk_data_matrix) <- gene_names
luk_data_matrix_cpm <- as.matrix(luk_data_matrix)
# Complete the cpm step
cpm_data <- edgeR::cpm(luk_data_matrix_cpm)
# Now we will filter the data
keep <- rowSums(cpm_data > 1) >= min_num_samples
filtered_data_matrix <- luk_data_matrix_cpm[keep, ]
filtered_data_matrix
d = DGEList(counts=filtered_data_matrix, group=luk_samples_dt$treatment)
d = calcNormFactors(d)
normalized_counts <- cpm(d)
normalized_counts
heatmap_matrix <- normalized_count_data
heatmap_matrix <- normalized_counts
rownames(normalized_counts)
if(min(normalized_counts) == 0){
heatmap_col = colorRamp2(c( 0, max(normalized_counts)),
c( "white", "red"))
} else {
heatmap_col = colorRamp2(c(min(normalized_counts), 0,
max(normalized_counts)), c("blue", "white", "red"))
}
current_heatmap <- Heatmap(as.matrix(heatmap_matrix),
show_row_dend = TRUE,show_column_dend = TRUE,
col=heatmap_col,show_column_names = TRUE,
show_row_names = FALSE,show_heatmap_legend = TRUE)
current_heatmap
png("heatmap.png", width = 800, height = 600)
current_heatmap
top_hits <- rownames(qlf_output_hits$table)[qlf_output_hits$table$PValue<0.05]
heatmap_matrix_tophits <- t(
scale(t(normalized_counts[which(rownames(normalized_counts) %in% top_hits),])))
top_hits <- rownames(qlf_output_hits$table)[qlf_output_hits$table$PValue<0.05]
heatmap_matrix_tophits <- t(
scale(t(normalized_counts[which(rownames(normalized_counts) %in% top_hits),])))
if(min(heatmap_matrix_tophits) == 0){
heatmap_col = colorRamp2(c( 0, max(heatmap_matrix_tophits)),
c( "white", "red"))
} else {
heatmap_col = colorRamp2(c(min(heatmap_matrix_tophits), 0,
max(heatmap_matrix_tophits)), c("blue", "white", "red"))
}
current_heatmap <- Heatmap(as.matrix(heatmap_matrix_tophits),
show_row_dend = TRUE,show_column_dend = TRUE,
col=heatmap_col,show_column_names = TRUE,
show_row_names = FALSE,show_heatmap_legend = TRUE)
current_heatmap
heatmap_matrix_tophits
top_hits
op_hits <- rownames(qlf_output_hits$table)[qlf_output_hits$table$FDR < 0.05]
heatmap_matrix_tophits <- t(
scale(t(normalized_counts[which(rownames(normalized_counts) %in% top_hits),])))
heatmap_matrix_tophits
min(heatmap_matrix_tophits)
min(heatmap_matrix_tophits)
str(heatmap_matrix_tophits)
top_hits
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("edgeR")
library(edgeR)
min_num_samples <- 10
luk_data_matrix <- as.matrix(luk_data)
gene_names <- luk_data_matrix[, 1]
# Now ill convert the rest of the columns to numeric matrix except the first one
luk_data_matrix <- luk_data_matrix[, -1]
luk_data_matrix <- apply(luk_data_matrix, 2, as.numeric)
row.names(luk_data_matrix) <- gene_names
luk_data_matrix_cpm <- as.matrix(luk_data_matrix)
# Complete the cpm step
cpm_data <- edgeR::cpm(luk_data_matrix_cpm)
# Now we will filter the data
keep <- rowSums(cpm_data > 1) >= min_num_samples
filtered_data_matrix <- luk_data_matrix_cpm[keep, ]
# I will apply TMM
d = DGEList(counts=filtered_data_matrix, group=luk_samples_dt$treatment)
# calculate normalization factors
d = calcNormFactors(d)
# apply cpm on the normalized data.
# This is the final data set the question in normalization is asking for
normalized_counts <- cpm(d)
# Set up the plotting window to have 4 plots in a single row
par(mfrow = c(1, 3))
# Now plot each MDS plot in turn, each will appear in its own slot
plotMDS(d, labels=NULL, pch=1, col=c("darkgreen","blue","yellow")[factor(luk_samples_dt$treatment)])
legend("topright", legend=levels(factor(luk_samples_dt$treatment)), pch=c(1), col=c("darkgreen","blue","yellow"), title="Treatment", bty='n', cex=0.75)
plotMDS(d, labels=NULL, pch=1, col=c("darkgreen","blue","yellow")[factor(luk_samples_dt$`cell line`)])
legend("topright", legend=levels(factor(luk_samples_dt$`cell line`)), pch=c(1), col=c("darkgreen","blue","yellow"), title="Cell Line", bty='n', cex=0.75)
plotMDS(d, labels=NULL, pch=1, col=c("darkgreen","blue","yellow")[factor(luk_samples_dt$genotype)])
legend("topright", legend=levels(factor(luk_samples_dt$genotype)), pch=c(1), col=c("darkgreen","blue","yellow"), title="Cell Line", bty='n', cex=0.75)
# Creating the model with the cell line and the treatment on the cells as the independent variables
model_design_pat <- model.matrix(~ luk_samples_dt$treatment + luk_samples_dt$`cell line`)
model_design_pat[1:5,1:5]
# Estimating the dispersion
d = DGEList(counts=filtered_data_matrix, group=luk_samples_dt$treatment)
d <- estimateDisp(d, model_design_pat)
fit <- glmQLFit(d, model_design_pat)
# Perform the Quasi likelihood test
qlf.Azacitidine_vs_Decitabine <- glmQLFTest(fit, coef=ncol(model_design_pat))
# Extract top hits
qlf_output_hits <- topTags(qlf.Azacitidine_vs_Decitabine, sort.by = "PValue", n = nrow(d))
# With the p-value set to be 0.05, determine how many were accepted after the test
length(which(qlf_output_hits$table$PValue < 0.05))
length(qlf_output_hits$table$PValue)
# With fdr correction, determine how many were accepted after the test
length(which(qlf_output_hits$table$FDR < 0.05))
# Load the libraries
library(ggplot2)
library(dplyr)
results <- qlf_output_hits$table
# Create the important variables
results$logP <- -log10(results$FDR)
results <- results %>%
mutate(expression = case_when(
logFC > 0.25 & results$FDR < 0.05 ~ "Upregulated",
logFC < -0.25 & results$FDR < 0.05 ~ "Downregulated",
TRUE ~ "No change"
))
# Create the volcano plot
ggplot(results, aes(x = results$logFC, y = results$logP, color = expression)) +
geom_point(alpha = 0.5) +
scale_color_manual(values = c('red', 'grey', 'blue')) +
theme_minimal() +
labs(x = "Log Fold Change", y = "Log 2 FDR values", title = "Volcano Plot") +
geom_vline(xintercept = c(-0.25, 0.25), linetype = "dotted") +
geom_hline(yintercept = -log2(0.05), linetype = "dotted")
top_hits <- rownames(qlf_output_hits$table)[qlf_output_hits$table$FDR < 0.05]
top_hits
heatmap_matrix_tophits <- t(
scale(t(normalized_counts[which(rownames(normalized_counts) %in% top_hits),])))
heatmap_matrix_tophits
if(min(heatmap_matrix_tophits) == 0){
heatmap_col = colorRamp2(c( 0, max(heatmap_matrix_tophits)),
c( "white", "red"))
} else {
heatmap_col = colorRamp2(c(min(heatmap_matrix_tophits), 0,
max(heatmap_matrix_tophits)), c("blue", "white", "red"))
}
current_heatmap <- Heatmap(as.matrix(heatmap_matrix_tophits),
show_row_dend = TRUE,show_column_dend = TRUE,
col=heatmap_col,show_column_names = TRUE,
show_row_names = FALSE,show_heatmap_legend = TRUE)
current_heatmap
png(filename = "heatmap_output.png")
current_heatmap
